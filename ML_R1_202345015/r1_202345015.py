# -*- coding: utf-8 -*-
"""R1_202345015.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c2s-Kg7xU9-kTDAAUD6SRwg_ADiGVE8i
"""

import pandas as pd
df = pd.read_csv('exam112.csv')
df.describe()
#print(df.columns)

df['pass'] = df['pass'].map({'Pass': 1, 'Fail': 0})

df.fillna(df.mean(), inplace=True)  # 평균값으로 채우기
df.fillna(df.median(), inplace=True)  # 중앙값으로 채우기
df.fillna(df.mode().iloc[0], inplace=True)  # 최빈값으로 채우기

Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1

# 이상치 판별 기준
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# 이상치 확인
outliers = (df < lower_bound) | (df > upper_bound)
print(outliers.sum())  # 각 열에서 이상치 개수 확인

df = df[~outliers.any(axis=1)]  # 이상치가 포함된 행 제거

df

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsRegressor, KNeighborsClassifier
import warnings
warnings.simplefilter(action='ignore', category=UserWarning)


# 데이터 불러오기
df = pd.read_csv("exam112.csv")

# '합격여부'를 숫자로 변환 (Pass → 1, Fail → 0)
df['pass'] = df['pass'].map({'Pass': 1, 'Fail': 0})

# 결측치 처리 (평균값으로 채우기)
df.fillna(df.mean(), inplace=True)

# 이상치 처리 (IQR 방식으로 제거)
Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1
df = df[~((df < (Q1 - 1.5 * IQR)) | (df > (Q3 + 1.5 * IQR))).any(axis=1)]

# 특성(X)과 타겟(y) 설정
X_reg = df[['math']]  # 회귀 모델 (수학 → 과학 점수 예측)
y_reg = df['science']

X_clf = df[['math', 'eng', 'science']]  # 분류 모델 (수학+영어+과학 → 합격 여부 예측)
y_clf = df['pass']

# 데이터 분할
X_reg_train, X_reg_test, y_reg_train, y_reg_test = train_test_split(X_reg, y_reg, test_size=0.2, random_state=42)
X_clf_train, X_clf_test, y_clf_train, y_clf_test = train_test_split(X_clf, y_clf, test_size=0.2, random_state=42)

# 데이터 정규화 (KNN은 거리 기반이므로 스케일링 필요)
scaler_reg = StandardScaler()
X_reg_train = scaler_reg.fit_transform(X_reg_train)
X_reg_test = scaler_reg.transform(X_reg_test)

scaler_clf = StandardScaler()
X_clf_train = scaler_clf.fit_transform(X_clf_train)
X_clf_test = scaler_clf.transform(X_clf_test)

# KNN 회귀 모델 (수학 → 과학 점수 예측)
knn_reg = KNeighborsRegressor(n_neighbors=5)
knn_reg.fit(X_reg_train, y_reg_train)

# KNN 분류 모델 (수학+영어+과학 → 합격 여부 예측)
knn_clf = KNeighborsClassifier(n_neighbors=5)
knn_clf.fit(X_clf_train, y_clf_train)

def predict_science():
    math_score = float(input("예측할 수학 점수를 입력하세요: "))
    math_score = np.array(math_score).reshape(-1, 1)  # 2D 배열로 변환
    math_score = scaler_reg.transform(math_score)  # 스케일링 적용
    predicted_science = knn_reg.predict(math_score)  # 예측
    print(f"예측된 과학 점수: {predicted_science[0]:.2f}")


def predict_pass():
    math_score = float(input("수학 점수를 입력하세요: "))
    english_score = float(input("영어 점수를 입력하세요: "))
    science_score = float(input("과학 점수를 입력하세요: "))

    input_scores = np.array([[math_score, english_score, science_score]])  # 2D 배열 유지
    input_scores = scaler_clf.transform(input_scores)  # 스케일링 적용
    predicted_pass = knn_clf.predict(input_scores)  # 예측
    result = "Pass" if predicted_pass[0] == 1 else "Fail"

    print(f"예측된 결과: {result}")


# 실행
print("1: 수학 점수 → 과학 점수 예측")
print("2: 수학, 영어, 과학 점수 → 합격 여부 예측")
choice = input("실행할 기능을 선택하세요 (1/2): ")

if choice == "1":
    predict_science()
elif choice == "2":
    predict_pass()
else:
    print("잘못된 입력입니다.")